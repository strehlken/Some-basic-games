# Some-basic-games
Work toward a simple coin tossing game to explore game theory with applications to poker and life

**20230803** The aim of this repository is to explore some basic game theory starting with simple games and moving to more complex ones. We will be very loose with the definition of game theory. The emphasis is on learning, and the goal is to sustain my own motivation to continue rather than to stick to a particular script or to achieve a particular objective. Thus part of the exploration here is an exploration of what learning process works best, and that means that content will sometimes be rough and similar to a diary. I will try to separate the polished finished content from the rough exploration.

To help guide my exploration, I wish to outline here a few topics and questions that I aim to address in the repository. I will refine this list as time goes on. The basic topics include:

1. **Before games:** betting against the house. Analysis of single player games such as betting on a weighted coin toss and is simpler than games in which we bet against an opponent who can also bet. This includes betting on a weighted coin toss and involves random walk analyses and basic statistics and probability
2. **Simple betting games:** here we try to find the basic components of betting games. We start with a very simple game in which two players privately flip a coin and win with heads or lose with tails. The players have an opportunity to bet on the outcome, and the optimal strategy is determined by the size of antes relative to the minimum bet. This is logically equivalent to a very simple analogue of hold em poker in which players flip a private coin and then flip a public coin which is the flop and then win if the flop matches their private flip. Goals include programming a very solid interactive version of this game, identifying and implementing the optimal strategy as a bot, and then creating a program by which automated strategies can train against one another and improve.
3. **Moderately complex games:** here we build on the simple games and hopefully put them together as components into more complex games. We will gradually add complexity, including multiple opponents and more complex betting and varied outcomes, but stay simpler than poker. Goals include identifying and refining the right "building blocks" to increase complexity in a flexible and understandable way that leads to playable games that can be tweaked
4. **Poker and similar games:** here we aim to use our building blocks to create a poker game and eventually to create and train poker bots. This is the ultimate "stretch" goal and will be an application of everything we have learned in simpler games. Ideally we can leverage the building blocks from steps 1-3 in order to create poker and train bots. Once we have done this, we can use them to learn the optimal poker strategy. This is a very long-term and ambitious goal and I'm fully aware it might be a pipe dream :)
5. **Further applications to life:** here we aim to use our flexible modular approach to develop interesting game theoretic applications that can shed light on real world problems such as those encountered in business or government. For instance, can we model a nuclear arms race? Can we create a game based on the rules and incentives typical of corporations and use this to run simulations and derive meaningful results? We will not limit ourselves to zero sum games but will include cooperative games. The main challenge here will be to formulate the questions in a precise way that at the same time retains enough of the real life problems to allow us to derive meaningful insights, replicate real-world results, and make predictions

A few guiding principles that we will use in development here:
* Modularity is more important than perfect flexibility. We want code that scales, with modular blocks built out of smaller modular blocks like a fractal all the way down to the simplest component. Modularity helps us understand what's going on and is worth potential prices in complexity and flexibility.
* Curiosity and motivation is more important than outcomes. If this stops being fun, I won't do it. It's great to set lofty goals because imagining the upside can be inspiring, but it's much more important to feel energized about opening up this repo day in and day out than to actually achieve those goals. If I don't open the repo, then I'm not even in the game. At the same time, if I don't think at all about goals I may also lose motivation. So it's a balance. However, the process is what's ultimately important, much more than the results.
* No question is too simple, but some are too complex. Honoring the simple and mundane is a great way to stay motivated and also a great way to learn. I place a lot of value on the foundation, which is built by relentlessly asking difficult but very simple questions.
* Iteration leads to organic growth. Stumbling on great nuggets of gold is less important than developing a very robust process which can start from any condition and then iteratively improve to reliable find nuggets of gold. We don't care about getting lucky and finding a good mining site so much as we care about figuring out how to mine. We also want organic growth, which is sometimes unpredictable.

## Running list of questions by topic

1. **Before games**
  - *(Kelley criterion.)* How much of your bankroll should you bet on an outcome with positive expected value? How, if at all, does this change if we have a high payoff outcome with low probability vs a relatively lower payoff outcome with high probability? How does it change if there are multiple outcomes with different payoffs and probabilities?
  - *(Sharpe ratio, tail risk.)* What are some ways to compare risk across different bets with the same expected value? Discuss when different approaches to assessing risk are appropriate by thinking through different cases. In particular, can you think of examples where the variance is poorly suited to assessing risk and a variance-driven approach leads to bankruptcy?
  - *(Efficient frontier.)* Write a program which takes as inputs a portfolio of stocks with chosen weights as well as a time horizon, and outputs (and plots) the performance of the portfolio over time. Extend this program to choose the optimal weights based on a given risk profile.
2. **Simple betting games** 
  - What is the optimal strategy in our simple coin toss betting game, particularly when the minimum bet size is smaller than the ante?
  - Write a program which allows a person to play the coin toss betting game against a computer. Extend it to allow simple prescription of the computer's strategy (formulate this requirement precisely!).
  - Write a program which allows two computer simulated strategies to play the coin toss betting game against each other and iteratively improve (define 'improvement' precisely!). Does it converge to an optimal strategy? Can this be written in such a way that the iterative improvement is optimal (define 'optimal' precisely!)?
3. **Moderately complex games**
4. **Poker and similar games**
5. **Further applications to life**
